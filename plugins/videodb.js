const { cmd } = require("../command");
const yts = require("yt-search");
const { ytmp4 } = require("@kelvdra/scraper");
const axios = require("axios");

const MAX_DOCUMENT_SIZE = 2 * 1024 * 1024 * 1024; // 2 GB

// Streamtape credentials (embedded)
const STREAMTAPE_USER = "23f14c5519cc5e3175ca";
const STREAMTAPE_KEY = "OkWybJzO6ah6K4";

// Utility to format file size
function formatBytes(bytes) {
  if (!bytes) return "0 Bytes";
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB", "TB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
}

// Clean file name title
function sanitizeTitle(title) {
  return title.replace(/[^\w\s-]/gi, "").replace(/\s+/g, "_").slice(0, 50);
}

// Generate styled bot message prompt
function botMessage({ statusEmoji, statusText, fileName, fileSize, source, actionText, link }) {
  return `
üî∞ *Senal-MD Bot* üî∞

‚è≥ *Status:* ${statusEmoji} ${statusText}
üìÅ *File Name:* \`${fileName}\`
üì¶ *Size:* ${fileSize}
üåê *Source:* ${source}

üõ†Ô∏è *Action:* ${actionText}
${link ? `üîó *Link:* ${link}` : ""}

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üåÄ *Generated by Mr Senal*
`.trim();
}

// Get file size from URL headers
async function getFileSize(url) {
  try {
    const res = await axios.head(url, { timeout: 10000 });
    return res.headers["content-length"] ? Number(res.headers["content-length"]) : 0;
  } catch {
    return 0;
  }
}

// Upload video URL to Streamtape
async function uploadToStreamtape(directUrl) {
  const apiUrl = `https://api.streamtape.com/file/ul?login=${STREAMTAPE_USER}&key=${STREAMTAPE_KEY}&url=${encodeURIComponent(directUrl)}`;
  const res = await axios.get(apiUrl);
  if (res.data.status !== 200) throw new Error("Upload to Streamtape failed");
  return res.data.result.url;
}

// Main command
cmd(
  {
    pattern: "vid",
    desc: "üì• YouTube Video Downloader (Streamtape Method)",
    category: "download",
    react: "üìπ",
  },
  async (robin, mek, m, { q, reply }) => {
    const from = mek.key.remoteJid;
    if (!q) return reply("üîç Please provide a video name or YouTube link.");

    try {
      await reply(botMessage({
        statusEmoji: "‚è≥",
        statusText: "Searching video on YouTube...",
        fileName: "-",
        fileSize: "-",
        source: "YouTube",
        actionText: "Please wait...",
        link: null,
      }));

      const search = await yts(q);
      const video = search.videos[0];
      if (!video) {
        return reply(botMessage({
          statusEmoji: "‚ùå",
          statusText: "No video found",
          fileName: "-",
          fileSize: "-",
          source: "YouTube",
          actionText: "Try another search query.",
          link: null,
        }));
      }

      await reply(botMessage({
        statusEmoji: "‚è¨",
        statusText: "Fetching download link...",
        fileName: video.title,
        fileSize: "-",
        source: "YouTube",
        actionText: "Getting video URL...",
        link: video.url,
      }));

      const result = await ytmp4(video.url, "360");
      if (!result?.download?.url) {
        return reply(botMessage({
          statusEmoji: "‚ùå",
          statusText: "Could not fetch download link",
          fileName: video.title,
          fileSize: "-",
          source: "YouTube",
          actionText: "Maybe age-restricted or unsupported.",
          link: video.url,
        }));
      }

      const downloadUrl = result.download.url;
      const fileSizeBytes = await getFileSize(downloadUrl);
      const sizeFormatted = fileSizeBytes > 0 ? formatBytes(fileSizeBytes) : "Unknown";
      const fileName = `${sanitizeTitle(video.title)}.mp4`;

      await reply(botMessage({
        statusEmoji: "üì§",
        statusText: "Uploading to Streamtape...",
        fileName,
        fileSize: sizeFormatted,
        source: "YouTube",
        actionText: "Uploading video stream...",
        link: null,
      }));

      const streamtapeUrl = await uploadToStreamtape(downloadUrl);

      await reply(botMessage({
        statusEmoji: "üì°",
        statusText: "Streaming to WhatsApp as document...",
        fileName,
        fileSize: sizeFormatted,
        source: "Streamtape",
        actionText: "Sending document to WhatsApp...",
        link: streamtapeUrl,
      }));

      const response = await axios.get(streamtapeUrl, { responseType: "stream" });
      const mime = response.headers["content-type"] || "video/mp4";

      await robin.sendMessage(
        from,
        {
          document: { stream: response.data },
          mimetype: mime,
          fileName,
          caption: `üé¨ *${video.title}*\nüì¶ *Size:* ${sizeFormatted}`,
        },
        { quoted: mek }
      );
    } catch (err) {
      console.error("Video Download Error:", err);
      await reply(botMessage({
        statusEmoji: "‚ùå",
        statusText: "Failed to process video",
        fileName: "-",
        fileSize: "-",
        source: "YouTube",
        actionText: "Please try again later.",
        link: null,
      }));
    }
  }
);
